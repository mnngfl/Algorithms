## 문제
#### 문제 설명
1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)

#### 제한 조건
- n은 2이상 1000000이하의 자연수입니다.

#### 입출력 예
|n|result|
|:-|:-|
|10|4|
|5|3|

#### 입출력 예 설명
입출력 예 #1<br>
1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환

입출력 예 #2<br>
1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환

## 풀이
#### 실패한 방법
처음에는 for(1..n) 반복문 안에서 현재 수(i)가 1과 자기 자신 외에 나누어 떨어지는지 몫을 2부터 자기 자신이 될 때 까지 증가시키며 그 여부를 조사하여 소수의 갯수를 알아내었다. 그랬더니 입출력 예제에 있는 테스트케이스는 통과하지만, 제출하기를 눌렀을 때 시간 초과 & 효율성 문제가 발생하였다. 이 방법은 만약 현재 구하려는 수가 소수라면 나누는 수가 자기 자신이 될 때까지 계속 반복문을 실행하게 된다는 특징이 있다. `2<=n<=1000000`이라는 n의 범위 때문에 이 방식튼 비효율적이라고 평가되는 듯 하다. 

#### 성공한 방법
**에라토스테네스의 체**를 활용한다. 이는 어떤 수가 소수임을 빠르고 정확하게 구할 수 있는 방법이다.

소수를 구하는 방법
- 소수는 1과 자기 자신 외에 약수가 존재하지 않는다.
- 어떤 수 n이 8이라면, n은 1\*8, 8\*1 이외에도 2\*4, 4\*2가 n을 나타낸다. 이렇게 어떤 수의 약수는 서로 대칭을 이루는 형태이다.
- 일반적으로 n이 소수라면, 이 n은 n의 제곱근보다 작거나 같은 어떠한 수로도 나누어 떨어지지 않는다. 어떤 수를 나누는 수와 몫 둘 중 하나는 무조건 `sqrt(n)` 이하의 수이다.
- 따라서 구하려는 숫자의 제곱근(`⎷n`)까지만 약수 존재 여부를 검증하면 빠르게 소수인지 판별할 수 있다. 또한 그만큼 연산 횟수도 줄어들게 된다.

에라토스테네스의 체
- 소수가 아닌 합성수들은 모두 소수와 소수의 곱으로 나타낼 수 있다. (ex. 4 = 2 \* 2, 16 = 2 \* 2 \* 2 \* 2)
- 자연수의 배열을 만든 후에, 가장 먼저 1을 지운다.
- 배열에서 가장 작은 수를 찾는다. 여기서 찾은 2는 약수가 1과 자기 자신뿐이므로 소수이다. 자기 자신을 제외한 소수 2의 배수를 모두 배열에서 삭제한다.
- 다음으로 배열에서 가장 작은 수를 찾는다. 3도 약수가 1과 자기 자신뿐이므로 소수이다. 자기 자신을 제외한 소수 3의 배수를 모두 배열에서 삭제한다.
- 이 과정을 `sqrt(n)`회 반복한다. 이후 체에서 걸러지지 않은(삭제되지 않은) 수들의 목록이 바로 소수의 목록이 되는 것이다.

## 출처
https://programmers.co.kr/learn/courses/30/lessons/12921
