## 문제
#### 문제 설명
배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.

예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면

1. array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.
2. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.
3. 2에서 나온 배열의 3번째 숫자는 5입니다.
배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.

#### 제한사항
- array의 길이는 1 이상 100 이하입니다.
- array의 각 원소는 1 이상 100 이하입니다.
- commands의 길이는 1 이상 50 이하입니다.
- commands의 각 원소는 길이가 3입니다.

#### 입출력 예
| array |	commands |	return |
|:-:|:-:|:-:|
| [1, 5, 2, 6, 3, 7, 4] |	[[2, 5, 3], [4, 4, 1], [1, 7, 3]] |	[5, 6, 3] |

#### 입출력 예 설명
[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.
[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.
[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.

## 풀이
#### Array.prototype.slice() vs. Array.prototype.splice()
배열을 자를 때 사용하는 메서드에 대한 비교
- `slice([begin[, end]])` 메서드는 `begin` 인덱스부터 `end`의 이전 인덱스까지에 대한 배열의 복사본을 반환한다. 이 때 원본 배열은 바뀌지 않는다.
- `splice(start[, deleteCount[, item1[, item2[, ...]]]])` 메서드는 `start` 인덱스부터 `deleteCounte` 만큼의 인덱스를 제거하고 해당 위치에 `item1`, `item2`, ...를 배열 요소로 추가한다. 이 때 원본 배열이 바뀌게 된다.

commands가 여러 개 주어지기 때문에 원본 배열을 바꾸면 안되므로 `slice` 메서드를 사용하였다.
이렇게 자른 배열을 `sort()` 메서드를 이용해 정렬하기만 하면 문제를 풀 수 있을 줄 알았는데, 테스트 케이스에서 자꾸 실패하게 되었다. 그 이유를 찾아 보니 자바스크립트의 `sort()` 메서드는 기본적으로 문자열 기준으로 항목을 정렬하기 때문이라는 사실을 알았다.

#### Array.prototype.sort()
숫자 정렬에서 원래는 `9 < 80`이 성립하지만, 이 메서드는 유니코드 기준으로 정렬하고 있으므로 유니코드 상에서는 `"80" < "9"`가 성립한다. 그러므로 이 경우 9라는 값보다 80이라는 값이 먼저 오도록 정렬이 된다.

이러한 경우에 대비해 `compareFunction`이라는 선택적 매개 변수를 전달할 수 있다. 만약 `sort()` 메서드를 숫자를 비교하는 용도로 사용하고자 한다면 다음과 같이 함수를 작성할 수 있다.
``` js
function compareNumbers(a, b) {
  return a - b;
}
```
이 함수를 넘겨줌으로써 배열 내의 숫자를 오름차순으로 정렬할 수 있게 된다. 만약 내림차순 정렬을 원한다면 `return a - b;` 부분을 `return b - a;`와 같이 변경할 수 있다.

## 출처
https://programmers.co.kr/learn/courses/30/lessons/42748
